// This was mostly generated by Cursor and desperately needs to be refactored.
//
// We handle Markdown and HTML conversion separately, which means we need to handle elements in three ways:
//   - Converting Markdown directly to Typst in a pulldown_cmark parse loop.
//   - Converting inline HTML fragments to Typst by simply matching strings and using a stack to handle unclosed tags.
//       - Inline HTML conversion is probably the most fragile part of this right now.
//       - Cursor also decided at one point to duplicate some of the string matching loop across async/sync fns. This needs to be cleaned up.
//   - Converting HTML blocks with an html_parser loop
//
// This should be refactored to first do a Markdown -> HTML conversion with pulldown_cmark, then do HTML -> Typst conversion in the html_parser loop (also it would maybe make sense to move to html5ever instead).

use anyhow::Result;
use html_escape::decode_html_entities;

#[cfg(all(not(feature = "fuzz"), feature = "node"))]
use napi::Error as NapiError;
#[cfg(all(not(feature = "fuzz"), feature = "node"))]
use napi_derive::napi;
use pulldown_cmark::{
    Alignment, BlockQuoteKind, CodeBlockKind, Event, HeadingLevel, Options, Parser, Tag, TagEnd,
};
use std::collections::HashMap;
use tokio::runtime::Runtime;

pub mod config;
mod html;
mod typst;
mod utils;

use crate::config::MdpdfConfig;
use crate::html::{block::HtmlToTypstConverter, inline::HtmlTagTracker};
use crate::typst::TypstCompiler;
use crate::utils::images::ImageProcessor;

const MAX_LIST_NESTING_LEVEL: usize = 15;
const MAX_BLOCKQUOTE_NESTING_LEVEL: usize = 8;

#[cfg(all(not(feature = "fuzz"), feature = "node"))]
#[napi]
pub async fn markdown_to_pdf(markdown: String) -> Result<napi::bindgen_prelude::Buffer, NapiError> {
    let config = MdpdfConfig::default();
    let (typst_code, image_files) =
        markdown_to_typst_async(&markdown, &config).await.map_err(|e| NapiError::from_reason(e))?;
    let pdf_bytes =
        typst_to_pdf(&typst_code, &config, image_files).map_err(|e| NapiError::from_reason(e))?;
    Ok(napi::bindgen_prelude::Buffer::from(pdf_bytes))
}

#[cfg(all(not(feature = "fuzz"), feature = "node"))]
#[napi]
pub async fn markdown_to_typst_code(markdown: String) -> Result<String, NapiError> {
    let config = MdpdfConfig::default();
    let (typst_code, _image_files) =
        markdown_to_typst_async(&markdown, &config).await.map_err(|e| NapiError::from_reason(e))?;
    Ok(typst_code)
}

async fn markdown_to_typst_async(
    markdown: &str,
    config: &MdpdfConfig,
) -> Result<(String, HashMap<String, Vec<u8>>), String> {
    let mut typst_code = String::new();

    let mut in_code_block = false;
    let mut current_code_block = String::new();

    let mut in_link = false;
    let mut current_link_text = String::new();
    let mut current_link_url = String::new();

    let mut in_heading = false;
    let mut current_heading_text = String::new();

    let mut in_image = false;
    let mut current_image_alt = String::new();
    let mut current_image_src = String::new();

    let mut list_nesting_level: usize = 0;
    let mut list_types: Vec<bool> = Vec::new(); // true for ordered, false for unordered
    let mut ordered_list_counters: Vec<usize> = Vec::new();

    let mut blockquote_nesting_level: usize = 0;

    let mut is_metadata_block = false;
    let mut current_metadata_block_text = String::new();

    let mut in_definition_list_title = false;

    // HTML fragment accumulation for split HTML blocks
    let mut html_fragments = Vec::new();
    let mut accumulating_html = false;

    let mut table_rows: Vec<Vec<String>> = Vec::new();
    let mut current_row: Vec<String> = Vec::new();
    let mut header_cells: Vec<String> = Vec::new();
    let mut current_cell_content = String::new();
    let mut in_table_cell = false;
    let mut in_table_header = false;
    let mut table_alignments: Vec<Alignment> = Vec::new();
    let mut table_column_count: usize = 0;

    let mut in_list_item = false;

    let image_processor = ImageProcessor::new(
        config
            .image_handling
            .as_ref()
            .and_then(|c| c.cache_directory_path()),
    );

    let mut image_files = HashMap::new();

    // Initialize HTML tag tracker for inline HTML processing
    let mut html_tag_tracker = HtmlTagTracker::new();

    let parser = Parser::new_ext(
        markdown,
        Options::ENABLE_TABLES
            | Options::ENABLE_STRIKETHROUGH
            | Options::ENABLE_DEFINITION_LIST
            | Options::ENABLE_MATH
            | Options::ENABLE_SUPERSCRIPT // TODO not working - use <sup></sup> and <sub></sub> instead
            | Options::ENABLE_GFM
            | Options::ENABLE_YAML_STYLE_METADATA_BLOCKS
            | Options::ENABLE_PLUSES_DELIMITED_METADATA_BLOCKS
            | Options::ENABLE_TASKLISTS,
        // | Options::ENABLE_FOOTNOTES
    );

    for event in parser {
        // println!("event: {:?}", event);
        // Get the current output buffer based on context
        let current_output: &mut String = if in_code_block {
            &mut current_code_block
        } else if in_image {
            &mut current_image_alt
        } else if in_link {
            &mut current_link_text
        } else if is_metadata_block {
            &mut current_metadata_block_text
        } else if in_table_cell {
            &mut current_cell_content
        } else if in_heading {
            &mut current_heading_text
        } else {
            &mut typst_code
        };

        match event {
            Event::Start(Tag::Heading { level, .. }) => {
                in_heading = true;
                let heading_marker = match level {
                    HeadingLevel::H1 => "=",
                    HeadingLevel::H2 => "==",
                    HeadingLevel::H3 => "===",
                    HeadingLevel::H4 => "====",
                    HeadingLevel::H5 => "=====",
                    HeadingLevel::H6 => "======",
                };
                typst_code.push_str(&format!("\n{heading_marker} "));
            }
            Event::End(TagEnd::Heading { .. }) => {
                in_heading = false;
                // Close any inline HTML tags at the end of headings
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    current_output.push_str(&closed_tags);
                }
                let kebab_case = to_kebab_case(&current_heading_text);
                if kebab_case.is_empty() {
                    typst_code.push_str(&format!("{current_heading_text}\n"));
                } else {
                    typst_code.push_str(&format!("{current_heading_text} <{kebab_case}>\n"));
                }
                current_heading_text.clear();
            }
            Event::Text(text) => {
                if in_code_block {
                    // For code blocks, filter problematic Unicode but don't escape Typst syntax
                    current_code_block.push_str(&filter_control_characters(&text));
                } else {
                    current_output.push_str(&escape_text(&text).to_string());
                }
            }
            Event::Start(Tag::Strong) => {
                current_output.push_str("#strong[");
            }
            Event::End(TagEnd::Strong) => {
                // Close any inline HTML tags at the end of bold blocks
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    current_output.push_str(&closed_tags);
                }
                current_output.push(']');
            }
            Event::Start(Tag::Emphasis) => {
                current_output.push_str("#emph[");
            }
            Event::End(TagEnd::Emphasis) => {
                // Close any inline HTML tags at the end of emphasis blocks
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    current_output.push_str(&closed_tags);
                }
                current_output.push(']');
            }
            Event::Start(Tag::Strikethrough) => {
                current_output.push_str("#strike[");
            }
            Event::End(TagEnd::Strikethrough) => {
                // Close any inline HTML tags at the end of strikethrough blocks
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    current_output.push_str(&closed_tags);
                }
                current_output.push(']');
            }
            Event::Start(Tag::CodeBlock(kind)) => {
                in_code_block = true;
                current_code_block.clear();
                // Get language for syntax highlighting
                let language = match kind {
                    CodeBlockKind::Fenced(lang) => lang.to_string(),
                    CodeBlockKind::Indented => String::new(),
                };
                // Start code block with syntax highlighting if language is specified
                if !language.is_empty() {
                    typst_code.push_str(&format!("```{language}\n"));
                } else {
                    typst_code.push_str("```\n");
                }
            }
            Event::End(TagEnd::CodeBlock) => {
                in_code_block = false;
                // Close any inline HTML tags at the end of code blocks
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    typst_code.push_str(&closed_tags);
                }
                // Add the collected code content
                typst_code.push_str(&current_code_block.replace("```", "\\`\\`\\`"));
                if current_code_block.ends_with("`") {
                    typst_code.push(' ');
                }
                typst_code.push_str("```\n");
            }
            Event::Start(Tag::Link { dest_url, .. }) => {
                in_link = true;
                current_link_text.clear();
                current_link_url = dest_url.to_string();
            }
            Event::End(TagEnd::Link) => {
                in_link = false;
                // TODO: do first pass where we inject some kind of tracking string, then come back later and replace those with a `label()` if the corresponding header exists. other replace with original #url
                // if current_link_url.starts_with("#") {
                //     typst_code.push_str(&format!(
                //         "#link(label(\"{}\"))[{}]", current_link_url.replace("#", ""), current_link_text
                //     ))
                // } else {
                let result = &format!(
                    "#link(\"{current_link_url}\")[{current_link_text}] (`{current_link_url}`)"
                );
                // Get the current output buffer based on context
                let current_output: &mut String = if in_code_block {
                    &mut current_code_block
                } else if in_link {
                    &mut current_link_text
                } else if is_metadata_block {
                    &mut current_metadata_block_text
                } else if in_table_cell {
                    &mut current_cell_content
                } else if in_heading {
                    &mut current_heading_text
                } else {
                    &mut typst_code
                };
                current_output.push_str(result);
            }
            Event::Start(Tag::Image { dest_url, .. }) => {
                in_image = true;
                current_image_alt.clear();
                current_image_src = dest_url.to_string();
            }
            Event::End(TagEnd::Image) => {
                in_image = false;

                // Get the alt text and process the image outside of the borrow scope
                let image_alt = current_image_alt.clone();
                let image_src = current_image_src.clone();

                // Process the image
                let result: Result<String, String> =
                    match image_processor.process_image_url(&image_src).await {
                        Ok(image_data) => {
                            // Convert to Typst format and add to image files
                            match image_processor
                                .convert_to_typst_format(&image_data, &image_alt)
                                .await
                            {
                                Ok((typst_image_code, converted_png_data)) => {
                                    // Extract filename from the generated code
                                    if let Some(filename) = typst_image_code.split('"').nth(1) {
                                        let _png_data_len = converted_png_data.len();
                                        image_files
                                            .insert(filename.to_string(), converted_png_data);
                                        Ok(typst_image_code)
                                    } else {
                                        // Fallback if parsing fails
                                        Ok(format!("#emph[Image: {}]", escape_text(&image_alt)))
                                    }
                                }
                                Err(_e) => {
                                    // Fallback on conversion error
                                    Ok(format!("#emph[Image: {}]", escape_text(&image_alt)))
                                }
                            }
                        }
                        Err(_e) => {
                            // Fallback on processing error
                            Ok(format!("#emph[Image: {}]", escape_text(&image_alt)))
                        }
                    };

                // Now add the result to the output using current_output
                if let Ok(output) = result {
                    // Get the current output buffer based on context (but not in_image anymore)
                    let current_output: &mut String = if in_code_block {
                        &mut current_code_block
                    } else if in_link {
                        &mut current_link_text
                    } else if is_metadata_block {
                        &mut current_metadata_block_text
                    } else if in_table_cell {
                        &mut current_cell_content
                    } else if in_heading {
                        &mut current_heading_text
                    } else {
                        &mut typst_code
                    };
                    current_output.push_str(&output);
                }
            }
            Event::Start(Tag::Item) => {
                in_list_item = true;
                if !in_code_block {
                    // Add indentation based on nesting level (2 spaces per level)
                    let indentation = "  ".repeat(list_nesting_level.saturating_sub(1));
                    if list_nesting_level > 0 && list_types[list_nesting_level - 1] {
                        // Ensure we have enough counters for the current nesting level
                        while ordered_list_counters.len() < list_nesting_level {
                            ordered_list_counters.push(1);
                        }
                        typst_code.push_str(&format!("\n{indentation}+ "));
                        ordered_list_counters[list_nesting_level - 1] += 1;
                    } else {
                        typst_code.push_str(&format!("\n{indentation}- "));
                    }
                }
            }
            Event::End(TagEnd::Item) => {
                in_list_item = false;
                if !in_code_block {
                    // Close any inline HTML tags at the end of list items
                    let closed_tags = html_tag_tracker.close_inline_tags();
                    if !closed_tags.is_empty() {
                        current_output.push_str(&closed_tags);
                    }
                }
            }
            Event::Code(code) => {
                // For inline code, apply Unicode filtering but don't escape anything other than triple backticks
                let filtered_code = filter_problematic_unicode(&code).replace("```", "\\`\\`\\`");

                let maybe_table_formatted_code = if in_table_cell {
                    // Insert zero-width spaces between every character so long code blocks can be wrapped
                    insert_zws_between_characters(&filtered_code)
                } else {
                    filtered_code
                };

                let back_padding = if maybe_table_formatted_code.ends_with("`") {
                    " "
                } else {
                    ""
                };
                current_output.push_str(&format!(
                    "``` {maybe_table_formatted_code}{back_padding}```"
                ));
            }
            Event::Start(Tag::BlockQuote(kind)) => {
                blockquote_nesting_level += 1;

                if blockquote_nesting_level <= MAX_BLOCKQUOTE_NESTING_LEVEL {
                    // Only create #quote[] blocks for the first N levels
                    typst_code.push_str("\n#quote[\n");
                    match kind {
                        Some(BlockQuoteKind::Note) => {
                            typst_code.push_str("\n#strong(text(blue)[ðŸ“‹ Note]) \n");
                        }
                        Some(BlockQuoteKind::Tip) => {
                            typst_code.push_str("\n#strong(text(green)[ðŸ’¡ Tip]) \n");
                        }
                        Some(BlockQuoteKind::Important) => {
                            typst_code.push_str("\n#strong(text(purple)[ï¸â˜ï¸ Important]) \n");
                        }
                        Some(BlockQuoteKind::Warning) => {
                            typst_code.push_str("\n#strong(text(orange)[âš ï¸ Warning]) \n");
                        }
                        Some(BlockQuoteKind::Caution) => {
                            typst_code.push_str("\n#strong(text(red)[ðŸš¨ï¸ Caution]) \n");
                        }
                        _ => {}
                    }
                }
                // For deeper nesting, do nothing - just continue at the same level
            }
            Event::End(TagEnd::BlockQuote(_)) => {
                if blockquote_nesting_level <= MAX_BLOCKQUOTE_NESTING_LEVEL {
                    // Close any inline HTML tags at the end of blockquotes
                    let closed_tags = html_tag_tracker.close_inline_tags();
                    if !closed_tags.is_empty() {
                        typst_code.push_str(&closed_tags);
                    }
                    // Only close #quote[] blocks for the first N levels
                    typst_code.push_str("\n]\n");
                }
                blockquote_nesting_level = blockquote_nesting_level.saturating_sub(1);
            }
            Event::SoftBreak => {
                if in_list_item {
                    current_output.push(' ');
                    continue;
                } else if in_definition_list_title {
                    continue;
                }
                if in_code_block {
                    current_code_block.push('\n');
                } else {
                    typst_code.push('\n');
                }
            }
            Event::HardBreak => {
                if in_definition_list_title {
                    continue;
                }
                if in_code_block {
                    current_code_block.push_str("\n\n");
                } else {
                    typst_code.push_str("\n\n");
                }
            }
            Event::Start(Tag::List(Some(_))) => {
                // TODO: cursor added this check but i don't think we could ever be in a list inside a code block
                if !in_code_block {
                    list_types.push(true);
                    if list_nesting_level == 0 {
                        typst_code.push('\n');
                    }
                    if list_nesting_level < MAX_LIST_NESTING_LEVEL {
                        list_nesting_level += 1;
                        // Initialize counter for this nesting level
                        while ordered_list_counters.len() < list_nesting_level {
                            ordered_list_counters.push(1);
                        }
                    }
                }
            }
            Event::Start(Tag::List(None)) => {
                // TODO: cursor added this check but i don't think we could ever be in a list inside a code block
                if !in_code_block {
                    list_types.push(false);
                    if list_nesting_level == 0 {
                        typst_code.push('\n');
                    }
                    if list_nesting_level < MAX_LIST_NESTING_LEVEL {
                        list_nesting_level += 1;
                    }
                }
            }
            Event::End(TagEnd::List(_)) => {
                // TODO: cursor added this check but i don't think we could ever be in a list inside a code block
                if !in_code_block {
                    list_types.pop();
                    list_nesting_level = list_nesting_level.saturating_sub(1);
                    // Remove counters for deeper nesting levels that are no longer needed
                    while ordered_list_counters.len() > list_nesting_level {
                        ordered_list_counters.pop();
                    }
                    // Close any inline HTML tags at the end of lists
                    let closed_tags = html_tag_tracker.close_inline_tags();
                    if !closed_tags.is_empty() {
                        typst_code.push_str(&closed_tags);
                    }
                }
            }
            Event::Rule => {
                current_output.push_str("\n#hrule\n");
            }
            Event::Html(html) => {
                let html_str = html.to_string();
                let trimmed = html_str.trim();

                if accumulating_html {
                    // We're inside an HTML block, accumulate the fragment
                    html_fragments.push(html_str);
                } else {
                    // This is a standalone HTML event, try to process it immediately
                    // Check if this looks like a complete HTML block
                    if trimmed.starts_with('<') && trimmed.ends_with('>') {
                        // This might be a complete HTML block, try to process it
                        let result =
                            convert_html_block(&html_str, &image_processor, &mut image_files).await;
                        if !result.trim().is_empty() {
                            typst_code.push_str(&result);
                        } else {
                            // If processing failed, accumulate for later
                            html_fragments.push(html_str);
                            accumulating_html = true;
                        }
                    } else {
                        // This is a fragment, accumulate it
                        html_fragments.push(html_str);
                        accumulating_html = true;
                    }
                }
            }
            Event::InlineHtml(html) => {
                // Handle inline HTML elements using the tag tracker
                current_output.push_str(
                    &html_tag_tracker
                        .process_html_tag(&html, &image_processor, &mut image_files)
                        .await,
                );
            }
            Event::InlineMath(math) => {
                // TODO
                let filtered_math = filter_problematic_unicode(&math);
                let padding = if filtered_math.ends_with("`") {
                    " "
                } else {
                    ""
                };
                current_output.push_str(&format!(" ``` {filtered_math}{padding}```"));
            }
            Event::DisplayMath(math) => {
                // TODO
                current_output.push_str(&format!(
                    "```math\n{}```\n",
                    filter_problematic_unicode(&math)
                ));
            }
            Event::Start(Tag::Paragraph) => {
                if !in_code_block && !in_list_item {
                    current_output.push('\n');
                }
            }
            Event::End(TagEnd::Paragraph) => {
                if !in_code_block && !in_list_item {
                    // Close any inline HTML tags at the end of paragraphs
                    let closed_tags = html_tag_tracker.close_inline_tags();
                    if !closed_tags.is_empty() {
                        current_output.push_str(&closed_tags);
                    }
                    current_output.push('\n');
                }
            }
            Event::TaskListMarker(marker) => {
                if marker {
                    current_output.push_str("ï¸â˜‘ ï¸Ž");
                } else {
                    current_output.push_str("â¬œ ");
                }
            }
            Event::Start(Tag::HtmlBlock) => {
                // Start accumulating HTML for a block-level element
                html_fragments.clear();
                accumulating_html = true;
            }
            Event::End(TagEnd::HtmlBlock) => {
                // End of HTML block - process accumulated fragments
                if accumulating_html && !html_fragments.is_empty() {
                    let combined_html = html_fragments.join("");
                    current_output.push_str(
                        &convert_html_block(&combined_html, &image_processor, &mut image_files)
                            .await,
                    );
                    html_fragments.clear();
                    accumulating_html = false;
                }
            }
            Event::Start(Tag::DefinitionList) => {}
            Event::End(TagEnd::DefinitionList) => {}
            Event::Start(Tag::DefinitionListTitle) => {
                in_definition_list_title = true;
                current_output.push_str("\n/ ");
            }
            Event::End(TagEnd::DefinitionListTitle) => {
                in_definition_list_title = false;
                current_output.push_str(": ");
            }
            Event::Start(Tag::DefinitionListDefinition) => {}
            Event::End(TagEnd::DefinitionListDefinition) => {
                current_output.push('\n');
            }
            Event::FootnoteReference(fnref) => {
                current_output.push_str(&format!("^{fnref}"));
            }
            Event::Start(Tag::FootnoteDefinition(fndef)) => {
                current_output.push_str(&format!("^{fndef}"));
            }
            Event::End(TagEnd::FootnoteDefinition) => {
                // Note: fndef is not available in End event, so we just close the footnote
                current_output.push('\n');
            }
            Event::Start(Tag::Superscript) => {
                current_output.push_str("\n#super[\n");
            }
            Event::End(TagEnd::Superscript) => {
                current_output.push_str("\n]\n");
            }
            Event::Start(Tag::Subscript) => {
                current_output.push_str("\n#sub[\n");
            }
            Event::End(TagEnd::Subscript) => {
                current_output.push_str("\n]\n");
            }
            Event::Start(Tag::MetadataBlock(_kind)) => {
                // TODO:
                // match kind {
                //     MetadataBlockKind::YamlStyle => {
                //         typst_code.push_str("\n#meta[\n");
                //     },
                //     MetadataBlockKind::PlusesStyle => {
                //         typst_code.push_str("\n#meta[\n");
                //     },
                // }
                is_metadata_block = true;
            }
            Event::End(TagEnd::MetadataBlock(_kind)) => {
                is_metadata_block = false;
                // println!("{}", current_metadata_block_text);
            }
            Event::Start(Tag::Table(alignment)) => {
                // Start table with proper Typst syntax
                table_rows.clear();
                header_cells.clear();
                table_alignments = alignment.clone();
                table_column_count = alignment.len();
            }
            Event::End(TagEnd::Table) => {
                // Close any inline HTML tags at the end of tables
                let closed_tags = html_tag_tracker.close_inline_tags();
                if !closed_tags.is_empty() {
                    current_output.push_str(&closed_tags);
                }
                current_output.push_str("#{\n");
                // Generate alignment directive based on captured alignments
                if !table_alignments.is_empty() {
                    current_output.push_str("  set table(align: (x, _) => ");
                    let mut alignment_conditions = Vec::new();
                    for (i, alignment) in table_alignments.iter().enumerate() {
                        let align_str = match alignment {
                            Alignment::Left => "left",
                            Alignment::Center => "center",
                            Alignment::Right => "right",
                            Alignment::None => "left", // Default to left for None
                        };
                        if i == 0 {
                            alignment_conditions.push(format!("if x == {i} {{ {align_str} }}"));
                        } else if i == 1 {
                            alignment_conditions.push(format!("if x == {i} {{ {align_str} }}"));
                        } else {
                            alignment_conditions.push(format!("{{ {align_str} }}"));
                            break;
                        }
                    }
                    current_output.push_str(&alignment_conditions.join(" else "));
                    current_output.push_str(")\n");
                }

                // Make header row bold
                current_output.push_str("  show table.cell.where(y: 0): strong\n");

                // Start table with correct column count
                current_output
                    .push_str(&format!("  table(\n      columns: {table_column_count},\n"));

                // Add header cells
                if !header_cells.is_empty() {
                    current_output.push_str("      ");
                    for (i, cell) in header_cells.iter().enumerate() {
                        if i > 0 {
                            current_output.push_str(", ");
                        }
                        current_output.push_str(&format!("[{cell}]"));
                    }
                    current_output.push_str(",\n");
                }

                // Add data rows
                for row in table_rows.iter() {
                    current_output.push_str("      ");
                    for (i, cell) in row.iter().enumerate() {
                        if i > 0 {
                            current_output.push_str(", ");
                        }
                        current_output.push_str(&format!("[{cell}]"));
                    }
                    current_output.push_str(",\n");
                }

                current_output.push_str("  )\n}\n");
            }
            Event::Start(Tag::TableRow) => {
                // Start table row
                current_row.clear();
            }
            Event::End(TagEnd::TableRow) => {
                // End table row - add the completed row to table_rows
                if !current_row.is_empty() {
                    table_rows.push(current_row.clone());
                }
            }
            Event::Start(Tag::TableHead) => {
                // Start table header
                in_table_header = true;
            }
            Event::Start(Tag::TableCell) => {
                // Start table cell - collect content
                in_table_cell = true;
                current_cell_content.clear();
            }
            Event::End(TagEnd::TableCell) => {
                // End table cell - add collected content to current row or header
                in_table_cell = false;
                if in_table_header {
                    header_cells.push(current_cell_content.clone());
                } else {
                    current_row.push(current_cell_content.clone());
                }
            }
            Event::End(TagEnd::TableHead) => {
                // End table header
                in_table_header = false;
            }
        }
    }

    // Process any remaining accumulated HTML fragments (for cases where HtmlBlock events aren't used)
    if accumulating_html && !html_fragments.is_empty() {
        let combined_html = html_fragments.join("");
        typst_code.push_str(
            &convert_html_block(&combined_html, &image_processor, &mut image_files).await,
        );
    }

    // Close any remaining open HTML tags
    let remaining_closes = html_tag_tracker.close_all_tags();
    if !remaining_closes.is_empty() {
        typst_code.push_str(&remaining_closes);
    }

    Ok((typst_code, image_files))
}

pub fn to_kebab_case(text: &str) -> String {
    // Check if any characters are RTL
    if text.chars().any(is_rtl_character) {
        return String::new();
    }
    text.replace(' ', "-")
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '_' || *c == '-' || *c == ':')
        .collect::<String>()
        .to_lowercase()
}

pub fn escape_text(text: &str) -> String {
    let filtered = filter_control_characters(text);
    let decoded = decode_html_entities(&filtered).into_owned();
    let escaped = escape_text_without_filtering(&decoded);
    // handle RTL at this point
    filter_problematic_unicode(&escaped)
}

fn insert_zws_between_characters(text: &str) -> String {
    let mut result = String::new();
    for c in text.chars() {
        result.push(c);
        result.push('\u{200B}');
    }
    result
}

pub fn escape_text_without_filtering(text: &str) -> String {
    text.replace("\\", "\\\\")
        .replace("/", "\\/")
        .replace("*", "\\*")
        .replace("[", "\\[")
        .replace("]", "\\]")
        .replace("@", "\\@")
        .replace("#", "\\#")
        .replace("=", "\\=")
        .replace("_", "\\_")
        .replace("+", "\\+")
        .replace("!", "\\!")
        .replace("\"", "\\\"")
        .replace("'", "\'")
        .replace("<", "\\<")
        .replace(">", "\\>")
        .replace("~", "\\~")
        .replace("$", "\\$")
        .replace("`", "\\`")
}

fn filter_control_characters(text: &str) -> String {
    text.chars()
        .filter(|&c| {
            // Filter out all control characters except essential whitespace
            match c {
                // Essential whitespace - preserve these
                '\t' | '\n' | '\r' => true, // Tab, Line Feed, Carriage Return

                // Control characters - filter out all of these
                '\0'..='\x08' | '\x0B' | '\x0C' | '\x0E'..='\x1F' => false,

                // All other characters - preserve
                _ => true,
            }
        })
        .collect()
}

/// Filter out problematic Unicode characters that can cause issues in Typst's text shaping engine.
/// This focuses on the specific characters that caused panics or other errors in fuzz testing.
/// Also wraps RTL text blocks with directional text wrappers to prevent mixed LTR/RTL panics.
pub fn filter_problematic_unicode(text: &str) -> String {
    let mut result = String::new();
    let mut current_rtl_block = String::new();
    let mut in_rtl_block = false;
    let mut pending_space = String::new();

    let filtered = filter_control_characters(text);

    for c in filtered.chars() {
        // Check if this character is RTL
        let is_rtl = is_rtl_character(c);

        if is_rtl {
            // If we're not in an RTL block, start one
            if !in_rtl_block {
                in_rtl_block = true;
                current_rtl_block.clear();
                pending_space.clear();
            }
            // Add any pending space to the RTL block (spaces between RTL characters)
            if !pending_space.is_empty() {
                current_rtl_block.push_str(&pending_space);
                pending_space.clear();
            }
            current_rtl_block.push(c);
        } else if c == '\n' || c == '\r' {
            // Newlines should break RTL blocks
            if in_rtl_block {
                // We were in an RTL block, so close it and add the wrapper
                if !current_rtl_block.is_empty() {
                    result.push_str(&format!("#text(dir: rtl)[{current_rtl_block}]"));
                }
                in_rtl_block = false;
                current_rtl_block.clear();
                pending_space.clear();
            }
            result.push(c);
        } else if c.is_whitespace() && in_rtl_block {
            // Store the space as pending - we'll add it to RTL block if next char is RTL
            pending_space.push(c);
        } else if in_rtl_block && (c.is_ascii_punctuation() || c.is_ascii_digit()) {
            // Include punctuation and digits in RTL blocks when we're already in an RTL block
            // This handles cases like "Ù…Ø±Ø­Ø¨Ø§! 123 ×©×œ×•×." where punctuation and numbers are part of RTL text
            if !pending_space.is_empty() {
                current_rtl_block.push_str(&pending_space);
                pending_space.clear();
            }
            current_rtl_block.push(c);
        } else {
            // This is an LTR character
            if in_rtl_block {
                // We were in an RTL block, so close it and add the wrapper
                if !current_rtl_block.is_empty() {
                    result.push_str(&format!("#text(dir: rtl)[{current_rtl_block}]"));
                }
                in_rtl_block = false;
                current_rtl_block.clear();
                // Don't add pending space to result - it will be added as LTR
            }
            // Add any pending space as LTR
            if !pending_space.is_empty() {
                result.push_str(&pending_space);
                pending_space.clear();
            }
            result.push(c);
        }
    }

    // Handle any remaining RTL block at the end
    if in_rtl_block && !current_rtl_block.is_empty() {
        result.push_str(&format!("#text(dir: rtl)[{current_rtl_block}]"));
    }

    result
}

/// Check if a character is a Right-to-Left character
fn is_rtl_character(c: char) -> bool {
    // Unicode ranges for RTL scripts
    match c {
        // Arabic
        '\u{0600}'..='\u{06FF}' |
        '\u{0750}'..='\u{077F}' |
        // Hebrew
        '\u{0590}'..='\u{05FF}' |
        '\u{FB1D}'..='\u{FB4F}' |
        // Syriac
        '\u{0700}'..='\u{074F}' |
        // Thaana
        '\u{0780}'..='\u{07BF}' |
        // N'Ko
        '\u{07C0}'..='\u{07FF}' |
        // Samaritan
        '\u{0800}'..='\u{083F}' |
        // Mandaic
        '\u{0840}'..='\u{085F}' |
        // Arabic Extended-A
        '\u{08A0}'..='\u{08FF}' |
        // Arabic Presentation Forms-A
        '\u{FB50}'..='\u{FDFF}' |
        // Arabic Presentation Forms-B
        '\u{FE70}'..='\u{FEFF}' |
        // Arabic Mathematical Alphabetic Symbols
        '\u{1EE00}'..='\u{1EEFF}' |
        // Arabic Extended-B
        '\u{1EF00}'..='\u{1EFFF}' |
        // RTL mark characters
        '\u{200F}' | // Right-to-Left Mark
        '\u{202B}' | // Right-to-Left Embedding
        '\u{202D}' | // Left-to-Right Override
        '\u{202E}' | // Right-to-Left Override
        '\u{2067}' | // Right-to-Left Isolate
        '\u{2068}' | // First Strong Isolate
        '\u{2069}'   // Pop Directional Isolate
        => true,
        _ => false,
    }
}

async fn convert_html_block(
    html: &str,
    image_processor: &ImageProcessor,
    image_files: &mut HashMap<String, Vec<u8>>,
) -> String {
    // For block HTML, we can use the full HTML parser
    let mut converter = HtmlToTypstConverter::new();
    let result = converter
        .convert_html_to_typst(html, image_processor, image_files)
        .await;

    // Check if this is a code block (contains ```)
    if result.trim().starts_with("```") && result.trim().ends_with("```") {
        // For code blocks, don't add extra newlines
        result
    } else if !result.is_empty() {
        // Add double newlines for other block elements
        format!("\n\n{}\n\n", result.trim())
    } else {
        String::new()
    }
}

pub fn markdown_to_typst(
    markdown: &str,
    config: &MdpdfConfig,
) -> Result<(String, HashMap<String, Vec<u8>>), String> {
    // Create a runtime for async operations
    let rt = Runtime::new().map_err(|e| format!("Failed to create runtime: {e}"))?;

    // Run the async function
    rt.block_on(markdown_to_typst_async(markdown, config))
}

pub fn typst_to_pdf(
    typst_code: &str,
    config: &MdpdfConfig,
    image_files: HashMap<String, Vec<u8>>,
) -> Result<Vec<u8>, String> {
    // Create the full Typst document with template
    let template = TypstCompiler::create_document_template(config);
    let full_document = format!("\n{template}\n\n{typst_code}\n"); // force newlines

    // Compile to PDF using our Typst compiler
    TypstCompiler::compile_to_pdf(full_document, config.clone(), image_files)
        .map_err(|e| e.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    fn run_async_test<F, T>(future: F) -> T
    where
        F: std::future::Future<Output = T>,
    {
        let rt = Runtime::new().unwrap();
        rt.block_on(future)
    }

    #[test]
    fn test_heading_conversion() {
        let markdown = "# Heading 1\n## Heading 2\n### Heading 3";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("= Heading 1"));
        assert!(typst_code.contains("== Heading 2"));
        assert!(typst_code.contains("=== Heading 3"));
    }

    #[test]
    fn test_bold_and_italic() {
        let markdown = "This is **bold** and this is *italic* text.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#strong[bold]"));
        assert!(typst_code.contains("#emph[italic]"));
    }

    #[test]
    fn test_code_blocks() {
        let markdown = r#"```rust
// Enhanced Rust example
use std::collections::HashMap;

#[derive(Debug)]
struct Cache<K, V> {
    data: HashMap<K, V>,
    max_size: usize,
}

impl<K, V> Cache<K, V> 
where 
    K: std::hash::Hash + Eq + Clone,
    V: Clone,
{
    fn new(max_size: usize) -> Self {
        Self {
            data: HashMap::new(),
            max_size,
        }
    }
    
    fn insert(&mut self, key: K, value: V) -> Option<V> {
        if self.data.len() >= self.max_size {
            // Remove oldest entry (simple implementation)
            if let Some(old_key) = self.data.keys().next().cloned() {
                self.data.remove(&old_key);
            }
        }
        self.data.insert(key, value)
    }
    
    fn get(&self, key: &K) -> Option<&V> {
        self.data.get(key)
    }
}

fn main() {
    let mut cache = Cache::new(3);
    cache.insert("a", 1);
    cache.insert("b", 2);
    cache.insert("c", 3);
    cache.insert("d", 4); // This will evict "a"
    
    println!("Cache: {:?}", cache);
}
```"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(&markdown));
    }

    #[test]
    fn test_code_blocks_python() {
        let markdown = r#"```python
# Enhanced Python example
from typing import List, Optional, Dict, Any
from dataclasses import dataclass
from datetime import datetime
import json

@dataclass
class User:
    id: int
    name: str
    email: str
    created_at: datetime
    preferences: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'created_at': self.created_at.isoformat(),
            'preferences': self.preferences
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'User':
        return cls(
            id=data['id'],
            name=data['name'],
            email=data['email'],
            created_at=datetime.fromisoformat(data['created_at']),
            preferences=data['preferences']
        )

class UserManager:
    def __init__(self):
        self.users: List[User] = []
    
    def add_user(self, user: User) -> None:
        self.users.append(user)
    
    def find_by_email(self, email: str) -> Optional[User]:
        return next((u for u in self.users if u.email == email), None)
    
    def export_to_json(self, filename: str) -> None:
        with open(filename, 'w') as f:
            json.dump([u.to_dict() for u in self.users], f, indent=2)

# Usage example
manager = UserManager()
user = User(
    id=1,
    name="John Doe",
    email="john@example.com",
    created_at=datetime.now(),
    preferences={"theme": "dark", "notifications": True}
)
manager.add_user(user)
print(f"User: {user}")
```
"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(&markdown));
    }

    #[test]
    fn test_inline_code() {
        let markdown = "Use the `println!` macro to print text.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("``` println!```"));
    }

    #[test]
    fn test_links() {
        let markdown = "[Rust](https://www.rust-lang.org/) is awesome!";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            "#link(\"https://www.rust-lang.org/\")[Rust] (`https://www.rust-lang.org/`)"
        ));
    }

    #[test]
    fn test_unordered_lists() {
        let markdown = "- Item 1\n- Item 2\n- Item 3";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("- Item 1"));
        assert!(typst_code.contains("- Item 2"));
        assert!(typst_code.contains("- Item 3"));
    }

    #[test]
    fn test_ordered_lists() {
        let markdown = "1. First item\n2. Second item\n3. Third item";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("+ First item"));
        assert!(typst_code.contains("+ Second item"));
        assert!(typst_code.contains("+ Third item"));
    }

    #[test]
    fn test_blockquotes() {
        let markdown = "> This is a blockquote.\n> It can span multiple lines.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#quote["));
        assert!(typst_code.contains("This is a blockquote."));
        assert!(typst_code.contains("It can span multiple lines."));
        assert!(typst_code.contains("]"));
    }

    #[test]
    fn test_horizontal_rules() {
        let markdown = "Some text\n\n---\n\nMore text";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#hrule"));
    }

    #[test]
    fn test_strikethrough() {
        let markdown = "This is ~~strikethrough~~ text.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#strike[strikethrough]"));
    }

    #[test]
    fn test_paragraphs() {
        let markdown = "First paragraph.\n\nSecond paragraph.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("First paragraph.\n\nSecond paragraph."));
    }

    #[test]
    fn test_html_blocks() {
        let markdown = "<div>This is HTML</div>";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("\n\nThis is HTML\n\n"));
    }

    #[test]
    fn test_html_replacement() {
        let markdown = "
<p>this is a
<div>paragraph</div> <span>with</span> <b>bold</b> and <i>italic</i> and <a href=\"https://www.google.com\">link</a></p> and <strong>strong</strong> and <em>em</em> and <ul><li>an unordered list</li></ul> and an <ol><li>ordered list</li></ol><video></video></p>";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(
            typst_code,
            "\n\nthis is a\n\nparagraph\nwith#strong[bold] and #emph[italic] and #link(\"https://www.google.com\")[link]\n and #strong[strong] and #emph[em] and \n- an unordered list\n and an \n+ ordered list\n\n"
        );
    }

    #[test]
    fn test_html_replacement_comprehensive() {
        // Test basic formatting elements
        let basic_html = "<p>Paragraph with <strong>bold</strong> and <em>italic</em> text.</p>";
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(basic_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#strong[bold]"));
        assert!(typst_code.contains("#emph[italic]"));

        // Test headings (should be converted to Typst headings)
        let heading_html = "<h1>Main Title</h1><h2>Subtitle</h2><h3>Section</h3>";
        let result = run_async_test(markdown_to_typst_async(heading_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("= Main Title"));
        assert!(typst_code.contains("== Subtitle"));
        assert!(typst_code.contains("=== Section"));

        // Test links with various formats
        let link_html = r#"<a href="https://example.com">Simple link</a>
<a href="https://example.com" target="_blank">Link with target</a>
<a href="https://example.com" title="Tooltip">Link with title</a>"#;
        let result = run_async_test(markdown_to_typst_async(link_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#link(\"https://example.com\")[Simple link]"));
        assert!(typst_code.contains("#link(\"https://example.com\")[Link with target]"));
        assert!(typst_code.contains("#link(\"https://example.com\")[Link with title]"));

        // Test images with various formats
        let image_html = r#"<img src="image.jpg" alt="Description">
<img src="image.png" alt="Description" width="100" height="50">
<img src="image.gif" alt="Description" title="Tooltip">"#;
        // <img src="https://upload.wikimedia.org/wikipedia/commons/4/48/Markdown-mark.svg" alt="Markdown logo">"#;
        let result = run_async_test(markdown_to_typst_async(image_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        // Since these are test URLs that don't exist, the ImageProcessor will fall back to text
        assert!(typst_code.contains("#emph[Image: Description]"));
        assert!(typst_code.contains("#emph[Image: Description]"));
        // assert!(typst_code.contains("#image(\"image_8e72a2235e41fbab.svg\", alt: \"Markdown logo\")"));

        // Test code elements
        let code_html = r#"<code>inline code</code>
<pre><code>block code
multiple lines</code></pre>"#;
        let result = run_async_test(markdown_to_typst_async(code_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("`inline code`"));
        assert!(typst_code.contains("```\nblock code\nmultiple lines\n```"));

        // Test blockquotes
        let quote_html = r#"<blockquote>This is a quote</blockquote>
<blockquote cite="https://example.com">Quote with citation</blockquote>"#;
        let result = run_async_test(markdown_to_typst_async(quote_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert!(typst_code.contains("#quote[This is a quote]"));
        assert!(
            typst_code
                .contains("#quote(attribution: \"https://example.com\")[Quote with citation]")
        );

        // Test lists with nested content
        let list_html = r#"<ul>
<li>Item 1 with <strong>bold</strong> text</li>
<li>Item 2 with <em>italic</em> text</li>
<li>Item 3 with <a href="https://example.com">link</a></li>
</ul>"#;
        let result = run_async_test(markdown_to_typst_async(list_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("- Item 1 with #strong[bold] text"));
        assert!(typst_code.contains("- Item 2 with #emph[italic] text"));
        assert!(typst_code.contains("- Item 3 with #link(\"https://example.com\")[link]"));

        // Test tables
        let table_html = r#"<table>
<tr><th>Header 1</th><th>Header 2</th></tr>
<tr><td>Cell 1</td><td>Cell 2</td></tr>
</table>"#;
        let result = run_async_test(markdown_to_typst_async(table_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            r#"#{
  show table.cell.where(y: 0): strong
  table(
      columns: 2,
      [Header 1], [Header 2],
      [Cell 1], [Cell 2],
  )
}
"#
        ));

        // Test line breaks and spacing
        let spacing_html = r#"<p>First line<br>Second line</p>
<p>Third line<br/>Fourth line</p>
<p>Fifth line<br />Sixth line</p>"#;
        let result = run_async_test(markdown_to_typst_async(spacing_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("First line\nSecond line\n"));
        assert!(typst_code.contains("Third line\nFourth line\n"));
        assert!(typst_code.contains("Fifth line\nSixth line\n"));

        // Test horizontal rules
        let hr_html = r#"<hr>
<hr/>
<hr />"#;
        let result = run_async_test(markdown_to_typst_async(hr_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#hrule"));

        // Test HTML entities
        let entities_html = r#"<p>&amp; &lt; &gt; &quot; &apos; &copy; &reg; &trade;</p>"#;
        let result = run_async_test(markdown_to_typst_async(entities_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("& \\< \\> \\\" ' Â© Â® â„¢"));

        // Test nested HTML structures
        let nested_html = r#"<div>
<p>Paragraph in div with <strong>bold <em>and italic</em> text</strong>.</p>
<ul>
<li>List item with <a href="https://example.com">link</a></li>
</ul>
</div>"#;
        let result = run_async_test(markdown_to_typst_async(nested_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#strong[bold #emph[and italic] text]"));
        assert!(typst_code.contains(r#"- List item with #link("https://example.com")[link]"#));

        // Test unsupported elements (should be stripped or converted to plain text)
        let unsupported_html = r#"<video src="video.mp4">Video content</video>
<audio src="audio.mp3">Audio content</audio>
<canvas>Canvas content</canvas>
<script>alert('hello');</script>
<style>body { color: red; }</style>"#;
        let result = run_async_test(markdown_to_typst_async(unsupported_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("Video content"));
        assert!(!typst_code.contains("</video>"));
        assert!(!typst_code.contains("body { color: red; }"));

        // Test malformed HTML (should be handled gracefully)
        let malformed_html = r#"<p>Unclosed paragraph
<strong>Unclosed bold
<em>Nested unclosed italic</em>
<a href="https://example.com">Unclosed link"#;
        let result = run_async_test(markdown_to_typst_async(malformed_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("Unclosed paragraph"));
        assert!(typst_code.contains("Unclosed bold"));
        assert!(typst_code.contains("#emph[Nested unclosed italic]"));
        assert!(typst_code.contains("Unclosed link"));

        // Test HTML with special characters in attributes
        let special_chars_html = r#"<a href="https://example.com/path?param=value&other=123">Link with query params</a>
<img src="image.jpg" alt="Image with &quot;quotes&quot; and &amp; symbols">"#;
        let result = run_async_test(markdown_to_typst_async(special_chars_html, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            "#link(\"https://example.com/path?param=value&other=123\")[Link with query params]"
        ));
        // Since this is a test URL that doesn't exist, the ImageProcessor will fall back to text
        assert!(typst_code.contains("#emph[Image: Image with \\\"quotes\\\" and & symbols]"));
        // Should handle special characters in URLs and attributes properly
    }

    #[test]
    fn test_tables() {
        let markdown = r#"| Header 1 | Header 2 | Header 3 |
|:----------|:----------:|----------:|
| Cell 1   | Cell 2   | Cell 3 |
| Cell 4   | Cell 5   | Cell 6 |
| Cell 7   | Cell 8   | Cell 9 | 
| Cell 10   | Cell 11   | Cell 12 |
"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // Tables are now properly parsed and converted to Typst table format
        assert!(typst_code.contains(
            r#"#{
  set table(align: (x, _) => if x == 0 { left } else if x == 1 { center } else { right })
  show table.cell.where(y: 0): strong
  table(
      columns: 3,
      [Header 1], [Header 2], [Header 3],
      [Cell 1], [Cell 2], [Cell 3],
      [Cell 4], [Cell 5], [Cell 6],
      [Cell 7], [Cell 8], [Cell 9],
      [Cell 10], [Cell 11], [Cell 12],
  )
}
"#
        ))
    }

    #[test]
    fn test_mixed_content() {
        let markdown = r#"# Title

This is a **bold** paragraph with `inline code`.

> This is a blockquote with *italic* text.

- List item 1
- List item 2

```rust
fn main() {
    println!("Hello");
}
```"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("= Title"));
        assert!(typst_code.contains("#strong[bold]"));
        assert!(typst_code.contains("``` inline code```"));
        assert!(typst_code.contains("#quote["));
        assert!(typst_code.contains("#emph[italic]"));
        assert!(typst_code.contains("- List item 1"));
        assert!(typst_code.contains("- List item 2"));
        assert!(typst_code.contains("```rust"));
        assert!(typst_code.contains("fn main()"));
    }

    #[test]
    fn test_empty_markdown() {
        let markdown = "";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.is_empty());
    }

    #[test]
    fn test_whitespace_only() {
        let markdown = "   \n\n  \t  \n";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // Should contain only whitespace/newlines
        assert!(typst_code.chars().all(|c| c.is_whitespace()));
    }

    #[test]
    fn test_nested_formatting() {
        let markdown = "This is **bold with *italic* inside** and `code`.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#strong[bold with #emph[italic] inside]"));
        assert!(typst_code.contains("``` code```"));
    }

    #[test]
    fn test_soft_and_hard_breaks() {
        let markdown = "Line 1\nLine 2\n\nLine 3";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("Line 1"));
        assert!(typst_code.contains("Line 2"));
        assert!(typst_code.contains("Line 3"));
    }

    #[test]
    fn test_escaped_characters() {
        let markdown = r#"This has \*escaped\* asterisks and \`escaped\` backticks."#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("\\*escaped\\*"));
        assert!(typst_code.contains("\\`escaped\\`"));
    }

    #[test]
    fn test_malformed_strikethrough() {
        let markdown = "This is ~~unclosed strikethrough text.";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("\\~\\~unclosed strikethrough text."));
    }

    #[test]
    fn test_code_block_without_language() {
        let markdown = r#"```
This is a code block without language specification.
```"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("```"));
        assert!(typst_code.contains("This is a code block without language specification."));
    }

    #[test]
    fn test_nested_lists() {
        let markdown = r#"- Level 1
  - Level 2
    - Level 3
  - Another Level 2
- Back to Level 1"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("- Level 1"));
        assert!(typst_code.contains("  - Level 2"));
        assert!(typst_code.contains("    - Level 3"));
        assert!(typst_code.contains("  - Another Level 2"));
        assert!(typst_code.contains("- Back to Level 1"));
    }

    #[test]
    fn test_nested_ordered_and_unordered_lists() {
        let markdown = r#"1. Level 1
2. Level 1
    1. Level 2
        1. Level 3
            1. Level 4
    2. Level 2
        1. Level 3
            - Unordered Level 4
    3. Back to Level 2
3. Back to Level 1
    - Unordered Level 2
    - Unordered
Level 2

hello"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert_eq!(
            typst_code,
            r#"

+ Level 1
+ Level 1
  + Level 2
    + Level 3
      + Level 4
  + Level 2
    + Level 3
      - Unordered Level 4
  + Back to Level 2
+ Back to Level 1
  - Unordered Level 2
  - Unordered Level 2
hello
"#
        );
    }

    #[test]
    fn test_definition_lists() {
        let markdown = r#"# Definition list

Term 1
:   Definition 1

Term 2
:   Definition 2
"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("Definition list"));
        assert!(typst_code.contains("/ Term 1: Definition 1"));
        assert!(typst_code.contains("/ Term 2: Definition 2"));
    }

    #[test]
    fn test_complex_nested_html() {
        let markdown = r#"<div>
<p>This is a paragraph inside a div with <strong>bold <em>and italic</em> text</strong>.</p>
<ul>
<li>List item with <a href="https://example.com">link</a></li>
</ul>
</div>
"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            r#"This is a paragraph inside a div with #strong[bold #emph[and italic] text]"#
        ));
        assert!(typst_code.contains(r#"- List item with #link("https://example.com")[link]"#));
    }

    #[test]
    fn test_complex_escaping() {
        let markdown = r#"Test escaping: `\*bold\*` `\`code\`` `\[link\]` `\#heading` `\=title` `\+list` `\"quote\"` `\'single\'` `\<tag\>` `\>close\>`"#;

        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(r#"Test escaping: ``` \*bold\*``` ``` \```code\````  ```\[link\]```  ```\#heading```  ```\=title```  ```\+list```  ```\"quote\"```  ```'single'```  ```\<tag\>```  ```\>close\>\`"#));
    }

    #[test]
    fn test_center_tag() {
        let markdown = "<center>This text should be centered</center>";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#{set align(center);[This text should be centered]}"));
    }

    #[test]
    fn test_center_tag_with_formatting() {
        let markdown =
            "<center>This text has <strong>bold</strong> and <em>italic</em> content</center>";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            "#{set align(center);[This text has #strong[bold] and #emph[italic] content]}"
        ));
    }

    #[test]
    fn test_code_block() {
        let markdown = r#"``` `hello` ```"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // The test input is a code block, so we should expect the content inside the code block
        assert!(typst_code.contains(" `hello` "));
    }

    #[test]
    fn test_unicode_filtering() {
        // Test the specific fuzz case that caused the panic
        let fuzz_case = "Ü°$K";
        let filtered = filter_problematic_unicode(fuzz_case);
        assert_eq!(filtered, "#text(dir: rtl)[Ü°$]K");

        // Test with all the characters from the fuzz test
        let fuzz_chars = "\u{0730}\u{0014}\u{0024}\u{0000}\u{0010}\u{004B}";
        let filtered = filter_problematic_unicode(fuzz_chars);
        assert_eq!(filtered, "#text(dir: rtl)[Ü°$]K");

        // Test that normal characters are preserved
        let normal_text = "Hello World 123 !@#";
        let filtered = filter_problematic_unicode(normal_text);
        assert_eq!(filtered, normal_text);

        // Test that control characters are filtered except whitespace
        let control_text = "Hello\nWorld\r\nTab\tSpace ";
        let filtered = filter_problematic_unicode(control_text);
        assert_eq!(filtered, "Hello\nWorld\r\nTab\tSpace ");

        // Test that null character is filtered
        let null_text = "Hello\u{0000}World";
        let filtered = filter_problematic_unicode(null_text);
        assert_eq!(filtered, "HelloWorld");
    }

    #[test]
    fn test_rtl_text_wrapping() {
        // Test pure RTL text
        let arabic_text = "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…";
        let filtered = filter_problematic_unicode(arabic_text);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…]");

        // Test pure Hebrew text
        let hebrew_text = "×©×œ×•× ×¢×•×œ×";
        let filtered = filter_problematic_unicode(hebrew_text);
        assert_eq!(filtered, "#text(dir: rtl)[×©×œ×•× ×¢×•×œ×]");

        // Test mixed LTR and RTL text
        let mixed_text = "Hello Ù…Ø±Ø­Ø¨Ø§ World ×©×œ×•×";
        let filtered = filter_problematic_unicode(mixed_text);
        assert_eq!(
            filtered,
            "Hello #text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§] World #text(dir: rtl)[×©×œ×•×]"
        );

        // Test RTL text at the beginning
        let rtl_start = "Ù…Ø±Ø­Ø¨Ø§ Hello";
        let filtered = filter_problematic_unicode(rtl_start);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§] Hello");

        // Test RTL text at the end
        let rtl_end = "Hello Ù…Ø±Ø­Ø¨Ø§";
        let filtered = filter_problematic_unicode(rtl_end);
        assert_eq!(filtered, "Hello #text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§]");

        // Test multiple RTL blocks separated by LTR
        let multiple_rtl = "Ù…Ø±Ø­Ø¨Ø§ Hello ×©×œ×•× World Ù…Ø±Ø­Ø¨Ø§";
        let filtered = filter_problematic_unicode(multiple_rtl);
        assert_eq!(
            filtered,
            "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§] Hello #text(dir: rtl)[×©×œ×•×] World #text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§]"
        );

        // Test RTL with punctuation and numbers
        let rtl_with_punct = "Ù…Ø±Ø­Ø¨Ø§! 123 ×©×œ×•×.";
        let filtered = filter_problematic_unicode(rtl_with_punct);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§! 123 ×©×œ×•×.]");

        // Test RTL with whitespace
        let rtl_with_whitespace = "Ù…Ø±Ø­Ø¨Ø§   ×©×œ×•×";
        let filtered = filter_problematic_unicode(rtl_with_whitespace);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§   ×©×œ×•×]");

        // Test RTL with newlines
        let rtl_with_newlines = "Ù…Ø±Ø­Ø¨Ø§\n×©×œ×•×";
        let filtered = filter_problematic_unicode(rtl_with_newlines);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§]\n#text(dir: rtl)[×©×œ×•×]");

        // Test empty RTL block (should not happen in practice, but test edge case)
        let empty_rtl = "";
        let filtered = filter_problematic_unicode(empty_rtl);
        assert_eq!(filtered, "");

        // Test RTL with control characters that should be filtered
        let rtl_with_control = "Ù…Ø±Ø­Ø¨Ø§\u{0000}×©×œ×•×";
        let filtered = filter_problematic_unicode(rtl_with_control);
        assert_eq!(filtered, "#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§×©×œ×•×]");
    }

    #[test]
    fn test_rtl_character_detection() {
        // Test Arabic characters
        assert!(is_rtl_character('Ø§')); // Arabic letter alef
        assert!(is_rtl_character('Ø¨')); // Arabic letter beh
        assert!(is_rtl_character('Øª')); // Arabic letter teh

        // Test Hebrew characters
        assert!(is_rtl_character('×')); // Hebrew letter alef
        assert!(is_rtl_character('×‘')); // Hebrew letter bet
        assert!(is_rtl_character('×’')); // Hebrew letter gimel

        // Test Syriac characters
        assert!(is_rtl_character('Ü')); // Syriac letter alap
        assert!(is_rtl_character('Ü’')); // Syriac letter beth

        // Test RTL mark characters
        assert!(is_rtl_character('\u{200F}')); // Right-to-Left Mark
        assert!(is_rtl_character('\u{202B}')); // Right-to-Left Embedding
        assert!(is_rtl_character('\u{202E}')); // Right-to-Left Override

        // Test LTR characters (should return false)
        assert!(!is_rtl_character('A'));
        assert!(!is_rtl_character('a'));
        assert!(!is_rtl_character('1'));
        assert!(!is_rtl_character('!'));
        assert!(!is_rtl_character(' '));
        assert!(!is_rtl_character('\n'));

        // Test CJK characters (should return false)
        assert!(!is_rtl_character('ä¸­'));
        assert!(!is_rtl_character('æ–‡'));
        assert!(!is_rtl_character('æ—¥'));
    }

    #[test]
    fn test_rtl_integration_with_markdown() {
        // Test RTL text in markdown headings
        let markdown = "# Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…\n## ×©×œ×•× ×¢×•×œ×";
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("= #text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…]"));
        assert!(typst_code.contains("== #text(dir: rtl)[×©×œ×•× ×¢×•×œ×]"));

        // Test RTL text in bold and italic
        let markdown = "**Ù…Ø±Ø­Ø¨Ø§** *×©×œ×•×*";
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(
            typst_code.contains(r#"#strong[#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§]] #emph[#text(dir: rtl)[×©×œ×•×]]"#)
        );

        // Test RTL text in links
        let markdown = "[Ù…Ø±Ø­Ø¨Ø§](https://example.com)";
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("#link(\"https://example.com\")[#text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§]]"));

        // Test mixed LTR/RTL in paragraphs
        let markdown = "Hello Ù…Ø±Ø­Ø¨Ø§ World ×©×œ×•×";
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains("Hello #text(dir: rtl)[Ù…Ø±Ø­Ø¨Ø§] World #text(dir: rtl)[×©×œ×•×]"));
    }

    #[test]
    fn test_blockquote_nesting() {
        let markdown = r#">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            r#"#quote[

#quote[

#quote[

#quote[

#quote[

#quote[

#quote[

#quote[

]

]

]

]

]

]

]

]"#
        ));
    }

    #[test]
    fn test_fuzz_19() {
        // unclosed indented backtick
        let markdown = r#"      `"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(
            typst_code,
            r#"```
  ` ```
"#
        );
    }

    #[test]
    fn test_fuzz_18() {
        // backtick in inline math
        let markdown = r#"*S$-* !0`$*` "#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(
            typst_code,
            r#"
#emph[S ``` -*!0` ```]\`
"#
        );
    }

    #[test]
    fn test_fuzz_12() {
        // unclosed inline html tag
        let markdown = r#"o!o5<U> <U<~"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(
            typst_code,
            r#"
o\!o5#underline[ \<U\<\~]
"#
        )
    }

    #[test]
    fn test_unclosed_html_tags() {
        let markdown = "<u>This text is underlined but the tag is never closed";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // Should contain the opening tag and be closed at the end of the document
        assert!(typst_code.contains("#underline["));
        // The tag should be closed at the end since there's no structural boundary
        assert!(typst_code.trim().ends_with("]"));
    }

    #[test]
    fn test_multiple_unclosed_html_tags() {
        let markdown = "<u>Underlined <strike>strikethrough <sup>superscript";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // Should contain all opening tags
        assert!(typst_code.contains("#underline["));
        assert!(typst_code.contains("#strike["));
        assert!(typst_code.contains("#super["));
        // Should end with all closing tags in reverse order (LIFO)
        assert!(typst_code.trim().ends_with("]]]"));
    }

    #[test]
    fn test_nested_html_tags() {
        let markdown = "<u>Underlined <strike>strikethrough</strike> text</u>";
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        // Should contain proper nesting
        assert!(typst_code.contains("#underline["));
        assert!(typst_code.contains("#strike["));
        assert!(typst_code.contains("strikethrough"));
        assert!(typst_code.contains("text"));
        // Should end with the closing bracket for the outer tag
        assert!(typst_code.trim().ends_with("]"));
    }

    #[test]
    fn test_invalid_nested_html() {
        let markdown =
            r#"## Second heading with **bold and <em>mixed emphasis** but em not closed"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert!(typst_code.contains(
            "= Second heading with #strong[bold and #emph[mixed emphasis]] but em not closed"
        ));
    }

    #[test]
    fn test_html_tags_closed_at_structural_boundaries() {
        let markdown = r#"**This is bold with <em>italic</em> text**

This is a new paragraph with <u>underlined text."#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();

        // The <em> tag should be closed within the bold section
        assert!(typst_code.contains("#strong[This is bold with #emph[italic] text]"));

        // The <u> tag should be closed at the end of the paragraph
        assert!(typst_code.contains("This is a new paragraph with #underline[underlined text.]"));
    }

    #[test]
    fn test_html_in_markdown_blocks() {
        let markdown = r#"**this is some <em>text**"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();

        assert!(typst_code.contains("#strong[this is some #emph[text]]"));

        // Should end with the closing of the bold section
        assert!(typst_code.trim().ends_with("]"));
    }

    #[test]
    fn test_unclosed_html_in_ordered_list() {
        let markdown = r#"1. Ordered list item with <strong>HTML strong tag
2. Second item with **markdown bold and <em>HTML em** but em not closed
3. Third item with [link with **bold inside](http://test.com) and *italic not closed
"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();

        assert!(typst_code.contains(r#"+ Third item with #link("http://test.com")[link with \*\*bold inside] (`http://test.com`) and \*italic not closed"#));
        assert!(typst_code.contains(
            "+ Second item with #strong[markdown bold and #emph[HTML em]] but em not closed"
        ));
        assert!(typst_code.contains("+ Ordered list item with #strong[HTML strong tag]"));
    }

    #[test]
    fn unsupported_html_tags() {
        let markdown = r#"<bdi> <bdo> <ruby> <rt> <rp>"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(typst_code, "\n    \n");
    }

    #[test]
    fn test_fuzz_24() {
        // unicode characters causing panic in typst
        let markdown = r#"Ö³!*"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(typst_code, "\n#text(dir: rtl)[\u{5b3}\\!]\\*\n");

        let markdown = "\u{5C5}";
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        assert_eq!(typst_code, "\n#text(dir: rtl)[\u{5c5}]\n");
    }

    #[test]
    fn test_fuzz_26() {
        // triple backticks inside single backticks
        let markdown = r#"`v```#c`v`````"#;
        let config = MdpdfConfig::default();

        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(
            typst_code,
            r#"
``` v\`\`\`#c```v\`\`\`\`\`
"#
        );
    }

    #[test]
    fn test_fuzz_27() {
        // backticks again
        let markdown = r#"`X``````* ```    `"#;
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        assert_eq!(typst_code, "\n``` X\\`\\`\\`\\`\\`\\`*\\`\\`\\` ```\n");
    }

    #[test]
    fn test_nested_element_spacing() {
        let markdown = r#"<p>This paragraph has <strong>bold</strong>, <em>italic</em>, <code>code</code>, and <a href="https://example.com">links</a> all mixed together.</p>"#;
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());

        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert_eq!(
            typst_code,
            r#"

This paragraph has #strong[bold], #emph[italic], `code`, and #link("https://example.com")[links] all mixed together.

"#
        );
    }

    #[test]
    fn test_quote_with_attribution() {
        let markdown = r#"### Academic Citations

> According to recent research findings, the implementation of advanced algorithms has shown significant improvements in processing efficiency.
>
> <cite>Johnson, A. et al. (2024). "Advanced Algorithm Implementation in Modern Systems." Journal of Computer Science, 45(3), 123-145.</cite>

"#;
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert_eq!(
            typst_code,
            r#"
=== Academic Citations <academic-citations>

#quote[

According to recent research findings, the implementation of advanced algorithms has shown significant improvements in processing efficiency.

#emph[Johnson, A. et al. (2024). \"Advanced Algorithm Implementation in Modern Systems.\" Journal of Computer Science, 45(3), 123-145.]

]
"#
        );
    }

    #[test]
    fn test_separated_list_items() {
        let markdown = r#"
- First item
- Second item
- Third item
- First item

- Second item

- Third item


1. Fourth item

2. Fifth item

3. Sixth item
test

test
"#;
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert_eq!(
            typst_code,
            r#"

- First item
- Second item
- Third item
- First item
- Second item
- Third item

+ Fourth item
+ Fifth item
+ Sixth item test
test
"#
        );
    }

    #[test]
    fn test_list_item_newlines() {
        let markdown = r#"
To facilitate merging any pull requests that you send, please:
- Reference the issue you are addressing with the text `Refs #<ISSUENUMBER>.`
  at the end of the subject line of each commit message, in *every commit*.
  Replace `<ISSUENUMBER>` with the number of the specific issue that your pull
  request is addressing.
- Describe what each commit does individually *in the commit's message*. It's
  best to err on the side of being more descriptive than less.
- Update the CHANGELOGs in the *last commit(s)*.

"#;
        let config = MdpdfConfig::default();
        let result = run_async_test(markdown_to_typst_async(markdown, &config));
        assert!(result.is_ok());
        let (typst_code, _) = result.unwrap();
        println!("{}", typst_code);
        assert_eq!(
            typst_code,
            r#"
To facilitate merging any pull requests that you send, please:


- Reference the issue you are addressing with the text ``` Refs #<ISSUENUMBER>.``` at the end of the subject line of each commit message, in #emph[every commit]. Replace ``` <ISSUENUMBER>``` with the number of the specific issue that your pull request is addressing.
- Describe what each commit does individually #emph[in the commit's message]. It's best to err on the side of being more descriptive than less.
- Update the CHANGELOGs in the #emph[last commit(s)]."#
        );
    }
}
